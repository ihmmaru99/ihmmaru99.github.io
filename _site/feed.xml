<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-06-12T10:23:15+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">IhmMaru99의 잡동사니</title><subtitle>ihmmaru99&apos;s blog</subtitle><author><name>임정빈</name></author><entry><title type="html">[백준][9663] N-Queen</title><link href="http://localhost:4000/boj/9663/" rel="alternate" type="text/html" title="[백준][9663] N-Queen" /><published>2023-06-12T00:00:00+09:00</published><updated>2023-06-12T00:00:00+09:00</updated><id>http://localhost:4000/boj/9663</id><content type="html" xml:base="http://localhost:4000/boj/9663/"><![CDATA[<h1 id="n-queen">N-Queen</h1>
<h2 id="난이도">난이도</h2>
<blockquote>
  <p><img src="https://github.com/ihmmaru99/ihmmaru99/assets/109266664/4f74cb65-a628-44e0-8f7f-210cdc98eb6e" alt="12" width="20px&quot;, height=&quot;20px" /> <span style="color:#FFBF00"> 골드 4</span></p>
</blockquote>

<h2 id="문제">문제</h2>
<p>N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.</p>

<p>N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.</p>
<h2 id="입력">입력</h2>
<p>첫째 줄에 N이 주어진다. (1 ≤ N &lt; 15)</p>
<h2 id="출력">출력</h2>
<p>첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.</p>
<h2 id="풀이">풀이</h2>
<blockquote>
  <p>백트래킹의 대표적인 문제이다. 가능한 경우의 수를 찾아서 1차원 배열 안에서 각 행에 위치한 퀸의 위치를 넣어서 가능한 경우의 수를 확인한다. NxN 판에서 N개의 퀸을 놓아야 하기 때문에 한 줄에 하나씩 퀸이 위치할 수 있어야 한다. 그렇기 때문에 모든 줄에는 퀸이 위치해야 하고 만약 모든 줄에 퀸이 위치할 수 없다면 그 경우는 해당 퀸을 위치시킬 수 없는 것이다. 이를 통해서 행과 열, 대각선을 검사해서 퀸을 모든 행에 위치시킬 수 있는지 확인한다. 같은 행을 검사할 필요없이 한 행에 값을 한개 넣을 수 있으므로 하나를 위치시켰다면 한 행은 넘어간다. 열 검사는 배열안에서 같은 값을 가지면 같은 열에 위치한 것이므로 이렇게 되면 위치시킬 수 없도록 한다. 대각선은 입력받은 값과 원래 기록되어있는 값의 인덱스 값을 비교해서 확인한다. 이렇게 검사해서 만약 놓을 수 있다면 다음 행으로 넘어가서 놓는 과정을 반복한다.</p>
</blockquote>

<h2 id="결과">결과</h2>
<p><a href="https://github.com/ihmmaru99/BOJ/blob/main/9663/9663.cpp">9663 - N-Queen</a></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="cp"># define MAX 15
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">col</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">check</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">level</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">col</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">||</span> <span class="n">abs</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">-</span> <span class="n">col</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">level</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nqueen</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">col</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">nqueen</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">nqueen</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="채점-결과">채점 결과</h1>]]></content><author><name>임정빈</name></author><category term="BOJ" /><category term="Algorithm" /><category term="Backtracking" /><category term="C++" /><summary type="html"><![CDATA[N-Queen 난이도 골드 4]]></summary></entry><entry><title type="html">[백준][20157] 화살을 쏘자!</title><link href="http://localhost:4000/boj/20157/" rel="alternate" type="text/html" title="[백준][20157] 화살을 쏘자!" /><published>2023-06-11T00:00:00+09:00</published><updated>2023-06-11T00:00:00+09:00</updated><id>http://localhost:4000/boj/20157</id><content type="html" xml:base="http://localhost:4000/boj/20157/"><![CDATA[<h1 id="화살을-쏘자">화살을 쏘자!</h1>
<h2 id="난이도">난이도</h2>
<blockquote>
  <p><img src="https://github.com/ihmmaru99/BOJ/assets/109266664/96cb338c-cf4e-498c-9ae4-c9632a0b73f4" alt="11" width="20px&quot;, height=&quot;20px" /> <span style="color:#FFBF00"> 골드 5</span></p>
</blockquote>

<h2 id="문제">문제</h2>
<p>호준이는 요즘 활 쏘기에 푹 빠져 있다. 열심히 활 쏘기를 연습하던 호준이는 쏠 때 마다 10점이 나오는 경지에 이르렀다. 이렇다 보니 한 방향으로 있는 과녁에 쏘는 것에 실증을 느낀 호준이는 새로운 방식의 활 쏘기를 시도해 보기로 하였다.</p>

<p>화살이 꽂힌 위치에 따라 점수를 얻는 기존의 방식과 다르게 2차원의 넓은 공터에 풍선을 (x, y)지점에 설치해 두고 지정된 위치 (0, 0) 에서 원하는 방향으로 화살을 쏜다. 화살은 진행 방향으로 무한히 뻗어 나갈 수 있으며, 이 화살이 날아가며 터트린 풍선의 수만큼 점수를 얻기로 했다. 풍선 한 개당 점수는 1점으로 동일하고 같은 위치에 2개 이상의 풍선을 둘 수 없다. 또한 호준이가 서있는 (0, 0)에도 풍선을 둘 수 없다.</p>

<p>호준이는 신중하게 방향을 설정해 한발을 쐈고, 자신이 선택하여 쏜 방향이 최선의 방향인지 궁금해진 호준이는 화살 하나로 얻을 수 있는 최대 점수가 궁금해졌다. 활쏘기 연습하느라 바쁜 호준이를 대신해서 풍선의 위치가 주어진다면 화살 한 개를 쏘아 얻을 수 있는 가장 높은 점수를 알려주자.</p>
<h2 id="입력">입력</h2>
<p>첫번째 줄에 풍선의 개수 정수 N(1 ≤ N  ≤ 100,000)이 주어진다.</p>

<p>다음 N개의 줄에는 풍선의 위치인 두 정수 x, y (-1,000,000 ≤ x, y ≤ 1,000,000)가 주어진다.</p>

<h2 id="출력">출력</h2>
<p>첫번째 줄에 화살 한 개를 쏘아 얻을 수 있는 최대 점수를 구해 출력한다.</p>

<h2 id="풀이">풀이</h2>
<blockquote>
  <p>같은 기울기 상에 있는 점들을 센 다음 각 기울기에 포함되는 점의 개수가 가장 큰 경우의 개수를 출력하면 된다. 그런데 이런 기울기를 단순히 분수로 표현하면 문제가 발생할 수 있다. c++에서 표현할 수 있는 소수점의 끝까지 표현하게 되었을 때 같다면 다르더라도 같은 값으로 표현할 수 있기 때문이다. 유한소수와 무한소수가 같다고 표현될 수 있기 때문에 이런 경우를 방지하기 위해서 각 점의 기울기를 나타날 수 있는 x,y 값을 서로소 관계로 표현해서 저장해서 개수를 세도록 했다.</p>
</blockquote>

<h2 id="결과">결과</h2>
<p><a href="https://github.com/ihmmaru99/BOJ/blob/main/20157/20157.cpp">20157 - 화살을 쏘자!</a></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">map</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">check</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
    <span class="k">while</span><span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">long</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">check</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
        <span class="n">m</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">make_pair</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">l</span><span class="p">,</span> <span class="n">x</span><span class="o">/</span><span class="n">l</span><span class="p">),</span> <span class="n">m</span><span class="p">[</span><span class="n">make_pair</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">l</span><span class="p">,</span> <span class="n">x</span><span class="o">/</span><span class="n">l</span><span class="p">)]</span><span class="o">++</span><span class="p">});</span>
        <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">l</span><span class="p">,</span> <span class="n">x</span><span class="o">/</span><span class="n">l</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="채점-결과">채점 결과</h2>
<p><img width="730" alt="스크린샷 2023-06-11 12 21 50" src="https://github.com/devxb/JJUNalgo/assets/109266664/6ae39921-8570-4ef2-a1e9-5d2a646974b4" /></p>]]></content><author><name>임정빈</name></author><category term="BOJ" /><category term="Algorithm" /><category term="C++" /><category term="Geometry" /><summary type="html"><![CDATA[화살을 쏘자! 난이도 골드 5]]></summary></entry><entry><title type="html">[백준][2527] 직사각형</title><link href="http://localhost:4000/boj/2527/" rel="alternate" type="text/html" title="[백준][2527] 직사각형" /><published>2023-06-10T00:00:00+09:00</published><updated>2023-06-10T00:00:00+09:00</updated><id>http://localhost:4000/boj/2527</id><content type="html" xml:base="http://localhost:4000/boj/2527/"><![CDATA[<h1 id="직사각형">직사각형</h1>
<h2 id="난이도">난이도</h2>
<blockquote>
  <p><img src="https://github.com/ihmmaru99/ihmmaru99.github.io/assets/109266664/1725e8ac-be34-44d1-a4db-174d0a2cd0dd" alt="10" width="20px&quot;, height=&quot;20px" /> <span style="color:#585858"> 실버 1</span></p>
</blockquote>

<h2 id="문제">문제</h2>
<p>2차원 격자공간에 두 개의 꼭짓점 좌표로 표현되는 직사각형이 있다. 직사각형은 아래와 같이 왼쪽 아래 꼭짓점 좌표 (x, y)와 오른쪽 위 꼭짓점 좌표 (p, q)로 주어진다.<br />
<img src="https://github.com/ihmmaru99/BOJ/assets/109266664/97e18321-3a8c-41ea-94d9-179078e39ba7" alt="preview" /><br />
이 문제에서 모든 직사각형은 두 꼭짓점의 좌표를 나타내는 4개의 정수 x y p q 로 표현된다. 단 항상 x&lt;p, y&lt;q 이다. 예를 들어 위 그림에 제시된 직사각형이라면 아래와 같이 표현된다.</p>
<div align="center">3 2 9 8</div>
<p>두 개의 직사각형은 그 겹치는 부분의 특성에 따라 다음 4가지 경우로 분류될 수 있다.</p>

<p>먼저 두 직사각형의 겹치는 부분이 직사각형인 경우이다. 아래 그림(a)는 공통부분이 직사각형인 경우의 3가지 예를 보여준다,<br />
<img src="https://github.com/ihmmaru99/BOJ/assets/109266664/9a6d319e-a350-4b45-aa00-4d4115903b4e" alt="preview-2" /><br />
또는 겹치는 부분이 아래 그림 (b)와 같이 선분이 될 수도 있고, 그림 (c)와 같이 점도 될 수 있다.<br />
<img src="https://github.com/ihmmaru99/BOJ/assets/109266664/867eb982-ed9d-4c09-81dc-cc03e7819363" alt="preview-3" /><br />
마지막으로 아래 그림 (d)와 같이 공통부분 없이 두 직사각형이 완전히 분리된 경우도 있다.<br />
<img src="https://github.com/ihmmaru99/BOJ/assets/109266664/43d41fe8-136d-4eee-8058-a5a32ac73842" alt="preview-4" /><br />
여러분은 두 직사각형의 겹치는 부분이 직사각형인지, 선분인지, 점인지, 아니면 전혀 없는 지를 판별해서 해당되는 코드 문자를 출력해야 한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">공통부분의 특성</th>
      <th style="text-align: center">코드 문자</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">직사각형</td>
      <td style="text-align: center">a</td>
    </tr>
    <tr>
      <td style="text-align: center">선분</td>
      <td style="text-align: center">b</td>
    </tr>
    <tr>
      <td style="text-align: center">점</td>
      <td style="text-align: center">c</td>
    </tr>
    <tr>
      <td style="text-align: center">공통부분이 없음</td>
      <td style="text-align: center">d</td>
    </tr>
  </tbody>
</table>

<h2 id="입력">입력</h2>
<p>4개의 줄로 이루어져 있다. 각 줄에는 8개의 정수가 하나의 공백을 두고 나타나는데, 첫 4개의 정수는 첫 번째 직사각형을, 나머지 4개의 정수는 두 번째 직사각형을 각각 나타낸다. 단 입력 직사각형의 좌표 값은 1이상 50,000 이하의 정수로 제한된다.</p>

<h2 id="출력">출력</h2>
<p>4개의 각 줄에 주어진 두 직사각형의 공통부분을 조사해서 해당하는 코드 문자를 출력파일의 첫 4개의 줄에 각각 차례대로 출력해야 한다.</p>

<h2 id="풀이">풀이</h2>
<blockquote>
  <p>겹치는 부분에 대해서 값을 찾아야 한다. 겹치는 부분의 상하좌우를 뽑아낸 다음에 x,y로 겹치는 부분이 모두 양수로 나온다면 해당 부분은 직사각형으로 겹치는 것일 것이라고 생각하면 된다. 둘이 겹치지 않는다면 겹치는 부분의 값이 음수로 나올 것이고 한 점에서 만나면 값이 0이 나올 것이다. 이를 구현하면 된다.</p>
</blockquote>

<h2 id="결과">결과</h2>
<p><a href="https://github.com/ihmmaru99/BOJ/blob/main/2527/2527.cpp">2527 - 직사각형</a></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">x1_s</span><span class="p">,</span> <span class="n">y1_s</span><span class="p">,</span> <span class="n">x1_e</span><span class="p">,</span> <span class="n">y1_e</span><span class="p">,</span> <span class="n">x2_s</span><span class="p">,</span> <span class="n">y2_s</span><span class="p">,</span> <span class="n">x2_e</span><span class="p">,</span> <span class="n">y2_e</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">xr</span><span class="p">,</span> <span class="n">xl</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">xd</span><span class="p">,</span> <span class="n">yd</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x1_s</span> <span class="o">&gt;&gt;</span> <span class="n">y1_s</span> <span class="o">&gt;&gt;</span> <span class="n">x1_e</span> <span class="o">&gt;&gt;</span> <span class="n">y1_e</span> <span class="o">&gt;&gt;</span> <span class="n">x2_s</span> <span class="o">&gt;&gt;</span> <span class="n">y2_s</span> <span class="o">&gt;&gt;</span> <span class="n">x2_e</span> <span class="o">&gt;&gt;</span> <span class="n">y2_e</span><span class="p">;</span>
        <span class="n">xr</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">x1_e</span><span class="p">,</span> <span class="n">x2_e</span><span class="p">);</span>
        <span class="n">xl</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">x1_s</span><span class="p">,</span> <span class="n">x2_s</span><span class="p">);</span>
        <span class="n">yt</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">y1_e</span><span class="p">,</span> <span class="n">y2_e</span><span class="p">);</span>
        <span class="n">yb</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">y1_s</span><span class="p">,</span> <span class="n">y2_s</span><span class="p">);</span>

        <span class="n">xd</span> <span class="o">=</span> <span class="n">xr</span> <span class="o">-</span> <span class="n">xl</span><span class="p">;</span>
        <span class="n">yd</span> <span class="o">=</span> <span class="n">yt</span> <span class="o">-</span> <span class="n">yb</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span><span class="n">xd</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">yd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'a'</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">xd</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">yd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'d'</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">xd</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">yd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'c'</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'b'</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="채점-결과">채점 결과</h2>]]></content><author><name>임정빈</name></author><category term="BOJ" /><category term="Algorithm" /><category term="C++" /><category term="Geometry" /><summary type="html"><![CDATA[직사각형 난이도 실버 1]]></summary></entry><entry><title type="html">[백준][2293] 동전1</title><link href="http://localhost:4000/boj/2293/" rel="alternate" type="text/html" title="[백준][2293] 동전1" /><published>2023-06-09T00:00:00+09:00</published><updated>2023-06-09T00:00:00+09:00</updated><id>http://localhost:4000/boj/2293</id><content type="html" xml:base="http://localhost:4000/boj/2293/"><![CDATA[<h1 id="동전-1">동전 1</h1>
<h2 id="난이도">난이도</h2>
<blockquote>
  <p><img src="https://github.com/ihmmaru99/BOJ/assets/109266664/96cb338c-cf4e-498c-9ae4-c9632a0b73f4" alt="11" width="20px&quot;, height=&quot;20px" /> <span style="color:#FFBF00"> 골드 5</span></p>
</blockquote>

<h2 id="문제">문제</h2>
<p>n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.</p>

<p>사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.</p>

<h2 id="입력">입력</h2>
<p>첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.</p>

<h2 id="출력">출력</h2>
<p>첫째 줄에 경우의 수를 출력한다. 경우의 수는 \(2^{31}\)보다 작다.</p>

<h2 id="풀이">풀이</h2>
<blockquote>
  <p>입력된 동전을 통해서 가능한 경우의 수를 모두 더해서 DP를 활용하면 된다. 1,2,5의 동전이 있다면 1만으로 10을 만드는 경우는 각각 1가지이다. 여기서 2를 더하면 1을 제외하고 각각의 경우에서 경우가 추가로 생기는 것을 알 수 있다. 2를 만드는 방법은 2개, 3을 만드는 방법은 2개, 4를 만드는 방법은 2+2,1+2+1, 1+1+1+1로 총 3개인데 기존에 1+1+1+1의 방법에서 2를 만드는 방법 2개가 추가되어서 3개가 된 것이다. dp[i] + dp[i-2]를 해주는 것과 같다. 다음 식을 일반화해서 문제를 해결하면 된다.</p>
</blockquote>

<h2 id="결과">결과</h2>
<p><a href="https://github.com/ihmmaru99/BOJ/blob/main/2293/2293.cpp">2293 - 동전1</a></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="mi">10001</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">num</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">k</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="채점-결과">채점 결과</h2>
<p><img width="730" alt="스크린샷 2023-06-09 14 10 09" src="https://github.com/ihmmaru99/BOJ/assets/109266664/92786188-a19d-4085-b4ea-4155e467c3d9" /></p>]]></content><author><name>임정빈</name></author><category term="BOJ" /><category term="Algorithm" /><category term="C++" /><category term="DP" /><summary type="html"><![CDATA[동전 1 난이도 골드 5]]></summary></entry><entry><title type="html">[백준][1715] 카드 정렬하기</title><link href="http://localhost:4000/boj/1715/" rel="alternate" type="text/html" title="[백준][1715] 카드 정렬하기" /><published>2023-06-09T00:00:00+09:00</published><updated>2023-06-10T00:00:00+09:00</updated><id>http://localhost:4000/boj/1715</id><content type="html" xml:base="http://localhost:4000/boj/1715/"><![CDATA[<h1 id="카드-정렬하기">카드 정렬하기</h1>
<h2 id="난이도">난이도</h2>
<blockquote>
  <p><img src="https://github.com/ihmmaru99/ihmmaru99/assets/109266664/4f74cb65-a628-44e0-8f7f-210cdc98eb6e" alt="12" width="20px&quot;, height=&quot;20px" /> <span style="color:#FFBF00"> 골드 4</span></p>
</blockquote>

<h2 id="문제">문제</h2>
<p>정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. 이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.</p>

<p>매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다. 그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.</p>

<p>N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.</p>

<h2 id="입력">입력</h2>
<p>첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.</p>

<h2 id="출력">출력</h2>
<p>첫째 줄에 최소 비교 횟수를 출력한다.</p>

<h2 id="풀이">풀이</h2>
<blockquote>
  <p>문제에서 작은 묶음을 먼저 묶으면서 진행하면 최선의 결과로 최소 비교 횟수를 얻을 수 있다. 이를 구현하기 위해서 우선순위 큐를 이용해서 구현한다. 우선순위 큐를 오름차순으로 받을 수 있도록 해서 계속해서 가장 작은 것을 먼저 합치도록 하면 된다.</p>
</blockquote>

<h2 id="결과">결과</h2>
<p><a href="https://github.com/ihmmaru99/BOJ/blob/main/1715/1715.cpp">1715 - 카드 정렬하기</a></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">;</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="n">pq</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
        <span class="n">cnt</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">;</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="채점-결과">채점 결과</h2>
<p><img width="730" alt="스크린샷 2023-06-10 14 27 21" src="https://github.com/ihmmaru99/BOJ/assets/109266664/82b78ea7-fb86-4aeb-b137-58c4a6ee8996" /></p>]]></content><author><name>임정빈</name></author><category term="BOJ" /><category term="Algorithm" /><category term="C++" /><category term="Greedy" /><category term="Queue" /><summary type="html"><![CDATA[카드 정렬하기 난이도 골드 4]]></summary></entry><entry><title type="html">[프로그래머스] 셔틀버스</title><link href="http://localhost:4000/programmers/shuttlebus/" rel="alternate" type="text/html" title="[프로그래머스] 셔틀버스" /><published>2023-06-08T00:00:00+09:00</published><updated>2023-06-09T00:00:00+09:00</updated><id>http://localhost:4000/programmers/shuttlebus</id><content type="html" xml:base="http://localhost:4000/programmers/shuttlebus/"><![CDATA[<h1 id="2018-kakao-blind-recruitment-셔틀버스">2018 KAKAO BLIND RECRUITMENT 셔틀버스</h1>
<h2 id="문제">문제</h2>
<p>카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 ‘크루’라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다.
이 문제에서는 편의를 위해 셔틀은 다음과 같은 규칙으로 운행한다고 가정하자.</p>
<ul>
  <li>셔틀은 09:00부터 총 n회 t분 간격으로 역에 도착하며, 하나의 셔틀에는 최대 m명의 승객이 탈 수 있다.</li>
  <li>셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다. 예를 들어 09:00에 도착한 셔틀은 자리가 있다면 09:00에 줄을 선 크루도 탈 수 있다.</li>
</ul>

<p>일찍 나와서 셔틀을 기다리는 것이 귀찮았던 콘은, 일주일간의 집요한 관찰 끝에 어떤 크루가 몇 시에 셔틀 대기열에 도착하는지 알아냈다. 콘이 셔틀을 타고 사무실로 갈 수 있는 도착 시각 중 제일 늦은 시각을 구하여라.
단, 콘은 게으르기 때문에 같은 시각에 도착한 크루 중 대기열에서 제일 뒤에 선다. 또한, 모든 크루는 잠을 자야 하므로 23:59에 집에 돌아간다. 따라서 어떤 크루도 다음날 셔틀을 타는 일은 없다.</p>

<h2 id="입력-형식">입력 형식</h2>
<p>셔틀 운행 횟수 n, 셔틀 운행 간격 t, 한 셔틀에 탈 수 있는 최대 크루 수 m, 크루가 대기열에 도착하는 시각을 모은 배열 timetable이 입력으로 주어진다.</p>
<ul>
  <li>0 ＜ n ≦ 10</li>
  <li>0 ＜ t ≦ 60</li>
  <li>0 ＜ m ≦ 45</li>
  <li>timetable은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이 HH:MM 형식으로 이루어져 있다.</li>
  <li>크루의 도착 시각 HH:MM은 00:01에서 23:59 사이이다.</li>
</ul>

<h2 id="출력-형식">출력 형식</h2>
<p>콘이 무사히 셔틀을 타고 사무실로 갈 수 있는 제일 늦은 도착 시각을 출력한다. 도착 시각은 HH:MM 형식이며, 00:00에서 23:59 사이의 값이 될 수 있다.</p>

<h2 id="풀이">풀이</h2>
<blockquote>
  <p>문제에서 사람이 오는 시간은 배열에 문자열의 형태로 저장되어 있다. 문자열을 정수로 반환하여 도착한 시간을 확인할 수 있도록 한다. 정수로 변환된 사람들의 도착시간을 오름차순으로 정렬한다. 정렬된 사람들을 통해서 셔틀버스에 해당 시간에 탈 수 있는지 확인한다. 만약 셔틀버스에 탈 수 있는 잔여석이 남아있고 현재 사람이 도착해있다면 그 사람은 해당 셔틀버스에 탈 수 있고 탔음을 표시한다. 그렇게 사람을 다 넣었으면 콘이 셔틀버스에 탈 수 있는 시간을 확인해야 한다. 만약 현재 도착한 사람들을 모두 태웠을 때 내가 탈 수 없다면 마지막에 탄 사람보다 1분 빨리 와야 하고 아니고 아직 맨 마지막에 정확히 도착하는 셔틀버스를 타도록 하면 된다. 이렇게 저장된 콘이 도착해야 되는 시간을 다시 문자열로 변환해서 출력할 수 있도록 하면 된다.</p>
</blockquote>

<h2 id="결과">결과</h2>
<p><a href="https://github.com/ihmmaru99/Programmers/blob/main/셔틀버스/셔틀버스.cpp">셔틀버스</a></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">string</span> <span class="nf">solution</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">timetable</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">answer</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">string</span> <span class="n">time</span> <span class="o">:</span> <span class="n">timetable</span><span class="p">)</span>
        <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">stoi</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">stoi</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)));</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">bus</span> <span class="o">=</span> <span class="mi">540</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">index</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bus</span><span class="p">){</span>
                <span class="n">index</span><span class="o">++</span><span class="p">;</span>
                <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">m</span><span class="p">){</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">bus</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">bus</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">result</span> <span class="o">/</span> <span class="mi">60</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="s">"0"</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="s">":"</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="s">":"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">minutes</span> <span class="o">=</span> <span class="n">result</span> <span class="o">%</span> <span class="mi">60</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">minutes</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="s">"0"</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">minutes</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">minutes</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="채점-결과">채점 결과</h2>
<p><img width="149" alt="스크린샷 2023-06-09 12 07 33" src="https://github.com/ihmmaru99/Programmers/assets/109266664/0ae294f6-be8e-4f23-9afb-2b8e1d5d33b4" /></p>]]></content><author><name>임정빈</name></author><category term="Programmers" /><category term="Algorithm" /><category term="C++" /><category term="Implementation" /><summary type="html"><![CDATA[2018 KAKAO BLIND RECRUITMENT 셔틀버스 문제 카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 ‘크루’라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다. 이 문제에서는 편의를 위해 셔틀은 다음과 같은 규칙으로 운행한다고 가정하자. 셔틀은 09:00부터 총 n회 t분 간격으로 역에 도착하며, 하나의 셔틀에는 최대 m명의 승객이 탈 수 있다. 셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다. 예를 들어 09:00에 도착한 셔틀은 자리가 있다면 09:00에 줄을 선 크루도 탈 수 있다.]]></summary></entry><entry><title type="html">[백준][11726] 2xn 타일링</title><link href="http://localhost:4000/boj/11726/" rel="alternate" type="text/html" title="[백준][11726] 2xn 타일링" /><published>2023-06-08T00:00:00+09:00</published><updated>2023-06-08T00:00:00+09:00</updated><id>http://localhost:4000/boj/11726</id><content type="html" xml:base="http://localhost:4000/boj/11726/"><![CDATA[<h1 id="2xn-타일링">2xn 타일링</h1>
<h2 id="난이도">난이도</h2>
<blockquote>
  <p><img src="https://github.com/ihmmaru99/ihmmaru99.github.io/assets/109266664/40f259a0-6d4e-4cfa-a954-225e9b42961f" alt="8" width="20px&quot;, height=&quot;20px" /> <span style="color:#585858"> 실버 3</span></p>
</blockquote>

<h2 id="문제">문제</h2>
<p>2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.</p>

<p>아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.<br />
<img src="https://github.com/ihmmaru99/BOJ/assets/109266664/e04b9615-225a-4d1a-97ef-eee0e05a658a" alt="1" /></p>

<h2 id="입력">입력</h2>
<p>첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)</p>

<h2 id="출력">출력</h2>
<p>첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.</p>

<h2 id="풀이">풀이</h2>
<blockquote>
  <p>DP를 이용해서 문제를 풀이하면 된다. 2x1을 만들 수 있는 경우의 수와 2x2를 만들 수 있는 경우의 수를 더하면 2x3을 만들 수 있는 경우의 수를 알 수 있다. 이를 통해서 점화식을 세워서 값을 배열에 저장해 놓으면 값을 알수 있다.</p>
</blockquote>

<h2 id="결과">결과</h2>
<p><a href="https://github.com/ihmmaru99/BOJ/blob/main/11726/11726.cpp">11726 - 2xn 타일링</a></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1001</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">%</span><span class="mi">10007</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="채점-결과">채점 결과</h2>
<p><img width="730" alt="스크린샷 2023-06-08 14 51 42" src="https://github.com/ihmmaru99/BOJ/assets/109266664/91f32128-84bf-43a7-b46b-73be22393bba" /></p>]]></content><author><name>임정빈</name></author><category term="BOJ" /><category term="Algorithm" /><category term="C++" /><category term="DP" /><summary type="html"><![CDATA[2xn 타일링 난이도 실버 3]]></summary></entry><entry><title type="html">[백준][1987] 알파벳</title><link href="http://localhost:4000/boj/1987/" rel="alternate" type="text/html" title="[백준][1987] 알파벳" /><published>2023-06-08T00:00:00+09:00</published><updated>2023-06-08T00:00:00+09:00</updated><id>http://localhost:4000/boj/1987</id><content type="html" xml:base="http://localhost:4000/boj/1987/"><![CDATA[<h1 id="알파벳">알파벳</h1>
<h2 id="난이도">난이도</h2>
<blockquote>
  <p><img src="https://github.com/ihmmaru99/ihmmaru99/assets/109266664/4f74cb65-a628-44e0-8f7f-210cdc98eb6e" alt="12" width="20px&quot;, height=&quot;20px" /> <span style="color:#FFBF00"> 골드 4</span></p>
</blockquote>

<h2 id="문제">문제</h2>
<p>세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.</p>

<p>말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.</p>

<p>좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.</p>
<h2 id="입력">입력</h2>
<p>첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R,C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다.</p>
<h2 id="출력">출력</h2>
<p>첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.</p>

<h2 id="풀이">풀이</h2>
<blockquote>
  <p>DFS를 이용해서 문제를 풀이했다. BFS로 문제를 풀이하려고 하니까 방문한 알파벳에 대해서 같은 반복문 안에서 다른 경우의 수를 세어서 다시 방문하라는 식으로 구현할 수 없었다. 그렇기 때문에 DFS로 서로 다른 알파벳이면 계속 방문하게 한 다음 가장 긴 경우의 수를 이전에 저장되어 있는 경우의 수의 방법의 길이와 비교하면서 업데이트하는 방식으로 코드를 작성했다. DFS의 재귀형태로 코드를 반복하면서 DFS의 재귀가 끝나면 방문했던 위치를 다시 방문하지 않았다고 표시하여 다시 방문할 수 있도록 했다.</p>
</blockquote>

<h2 id="결과">결과</h2>
<p><a href="https://github.com/ihmmaru99/BOJ/blob/main/1987/1987.cpp">1987 - 알파벳</a></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span>
<span class="cp"># define MAX 20
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="n">alphabet</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">,</span> <span class="p">};</span>

<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">map</span><span class="p">[</span><span class="n">MAX</span><span class="p">][</span><span class="n">MAX</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dx</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">dy</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">;</span>
    <span class="c1">// cout &lt;&lt; index;</span>
    <span class="n">alphabet</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">check</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">nindex</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">alphabet</span><span class="p">[</span><span class="n">nindex</span><span class="p">]){</span>
                <span class="n">alphabet</span><span class="p">[</span><span class="n">nindex</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">check</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
                <span class="n">alphabet</span><span class="p">[</span><span class="n">nindex</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">r</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">r</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">c</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/*
    for(int i=0; i&lt;r; i++){
        for(int j=0; j&lt;c; j++)
            cout &lt;&lt; map[i][j] &lt;&lt; ' ';
        cout &lt;&lt; '\n';
    }
    */</span>
   <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="채점-결과">채점 결과</h2>
<p><img width="730" alt="스크린샷 2023-06-08 21 09 22" src="https://github.com/ihmmaru99/BOJ/assets/109266664/98f8f03b-fe55-4236-8f41-a2748981f1f7" /></p>]]></content><author><name>임정빈</name></author><category term="BOJ" /><category term="Algorithm" /><category term="C++" /><category term="DFS" /><summary type="html"><![CDATA[알파벳 난이도 골드 4]]></summary></entry><entry><title type="html">[백준][11660] 구간 합 구하기 5</title><link href="http://localhost:4000/boj/11660/" rel="alternate" type="text/html" title="[백준][11660] 구간 합 구하기 5" /><published>2023-06-07T00:00:00+09:00</published><updated>2023-06-07T00:00:00+09:00</updated><id>http://localhost:4000/boj/11660</id><content type="html" xml:base="http://localhost:4000/boj/11660/"><![CDATA[<h1 id="구간-합-구하기-5">구간 합 구하기 5</h1>

<h2 id="난이도">난이도</h2>
<blockquote>
  <p><img src="https://github.com/ihmmaru99/ihmmaru99.github.io/assets/109266664/1725e8ac-be34-44d1-a4db-174d0a2cd0dd" alt="10" width="20px&quot;, height=&quot;20px" /> <span style="color:#585858"> 실버 1</span></p>
</blockquote>

<h2 id="문제">문제</h2>
<p>N×N개의 수가 N×N 크기의 표에 채워져 있다. (x1, y1)부터 (x2, y2)까지 합을 구하는 프로그램을 작성하시오. (x, y)는 x행 y열을 의미한다.</p>

<p>예를 들어, N = 4이고, 표가 아래와 같이 채워져 있는 경우를 살펴보자.</p>

<table>
  <tbody>
    <tr>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
    </tr>
    <tr>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
  </tbody>
</table>

<p>여기서 (2, 2)부터 (3, 4)까지 합을 구하면 3+4+5+4+5+6 = 27이고, (4, 4)부터 (4, 4)까지 합을 구하면 7이다.</p>

<p>표에 채워져 있는 수와 합을 구하는 연산이 주어졌을 때, 이를 처리하는 프로그램을 작성하시오.</p>

<h2 id="입력">입력</h2>
<p>첫째 줄에 표의 크기 N과 합을 구해야 하는 횟수 M이 주어진다. (1 ≤ N ≤ 1024, 1 ≤ M ≤ 100,000) 둘째 줄부터 N개의 줄에는 표에 채워져 있는 수가 1행부터 차례대로 주어진다. 다음 M개의 줄에는 네 개의 정수 x1, y1, x2, y2 가 주어지며, (x1, y1)부터 (x2, y2)의 합을 구해 출력해야 한다. 표에 채워져 있는 수는 1,000보다 작거나 같은 자연수이다. (x1 ≤ x2, y1 ≤ y2)</p>

<h2 id="출력">출력</h2>
<p>총 M줄에 걸쳐 (x1, y1)부터 (x2, y2)까지 합을 구해 출력한다.</p>

<h2 id="풀이">풀이</h2>
<blockquote>
  <p>일반적인 구간 합 문제에서는 단순히 for문을 돌린다면 시간초과를 마주하게 된다. 나 또한 마찬가지로 for문을 돌렸으나 시간초과가 되었다. 시간초과를 마주치지 않기 위해서는 DP를 활용해야 한다. DP를 활용해서 각 인덱스에 해당 인덱스까지의 구간합을 적어놓고 필요한 구간만큼의 값을 뽑아낼 수 있도록 한다.</p>
</blockquote>

<p><img width="404" alt="스크린샷 2023-06-07 16 07 20" src="https://github.com/ihmmaru99/BOJ/assets/109266664/83a10efe-e841-43e3-a86f-50d70f94cc69" /><br />
다음과 같은 그림에서 노란 구간의 합을 구하기 위해서는 각 맵에 전체의 구간합을 적어준 다음에 색칠되어 있는 전체 영역의 구간합에 - (파랑+초록) - (빨강+초록) + 초록을 하면 노란 영역만의 구간합을 구할 수 있다.</p>

<h2 id="결과">결과</h2>
<p><a href="https://github.com/ihmmaru99/BOJ/blob/main/11660/11660.cpp">11660 - 구간합구하기5</a></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="cp"># define MAX 1025
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">map</span><span class="p">[</span><span class="n">MAX</span><span class="p">][</span><span class="n">MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">temp</span><span class="p">;</span>
            <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">temp</span> <span class="o">-</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x_end</span><span class="p">,</span> <span class="n">y_end</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span> <span class="o">&gt;&gt;</span> <span class="n">x_end</span> <span class="o">&gt;&gt;</span> <span class="n">y_end</span><span class="p">;</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">x_end</span><span class="p">][</span><span class="n">y_end</span><span class="p">]</span> <span class="o">-</span> <span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">y_end</span><span class="p">]</span> <span class="o">-</span> <span class="n">map</span><span class="p">[</span><span class="n">x_end</span><span class="p">][</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="채점-결과">채점 결과</h2>
<p><img width="733" alt="스크린샷 2023-06-07 15 59 33" src="https://github.com/ihmmaru99/BOJ/assets/109266664/60f30917-88bc-436a-87a5-7810479c946a" /></p>]]></content><author><name>임정빈</name></author><category term="BOJ" /><category term="Algorithm" /><category term="C++" /><category term="DP" /><summary type="html"><![CDATA[구간 합 구하기 5]]></summary></entry><entry><title type="html">[백준][14502] 연구소</title><link href="http://localhost:4000/boj/14502/" rel="alternate" type="text/html" title="[백준][14502] 연구소" /><published>2023-06-07T00:00:00+09:00</published><updated>2023-06-07T00:00:00+09:00</updated><id>http://localhost:4000/boj/14502</id><content type="html" xml:base="http://localhost:4000/boj/14502/"><![CDATA[<h1 id="연구소">연구소</h1>
<h2 id="난이도">난이도</h2>
<blockquote>
  <p><img src="https://github.com/ihmmaru99/ihmmaru99/assets/109266664/4f74cb65-a628-44e0-8f7f-210cdc98eb6e" alt="12" width="20px&quot;, height=&quot;20px" /> <span style="color:#FFBF00"> 골드 4</span></p>
</blockquote>

<h2 id="문제">문제</h2>
<p>인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.</p>

<p>연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.</p>

<p>일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.</p>

<p>예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0
</code></pre></div></div>
<p>이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.</p>

<p>2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2 1 0 0 1 1 0
1 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 1 0
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0
</code></pre></div></div>
<p>바이러스가 퍼진 뒤의 모습은 아래와 같아진다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2 1 0 0 1 1 2
1 0 1 0 1 2 2
0 1 1 0 1 2 2
0 1 0 0 0 1 2
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0
</code></pre></div></div>
<p>벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.</p>

<p>연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.</p>

<h2 id="입력">입력</h2>
<p>첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)</p>

<p>둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.</p>

<p>빈 칸의 개수는 3개 이상이다.</p>

<h2 id="출력">출력</h2>
<p>첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.</p>

<h2 id="풀이">풀이</h2>
<blockquote>
  <p>BFS를 통해서 바이러스가 어떻게 퍼지는지 알아야 하는데 벽을 3개 세워서 각 경우에 대해서 안전 영역을 구할 수 있어야 하며 안전 영역이 가장 크게 생성되는 경우에서 안전 영역의 넓이를 구할 수 있어야 한다.</p>
</blockquote>

<p>주어진 맵의 경우에서 벽을 세울 수 있는 최선의 경우를 바로 찾는 방법은 없으므로 벽을 세울 수 있는 모든 경우를 탐색해야 하며 각 경우에서 최댓값을 저장해놓고 비교해야 한다. 벽을 3개 세웠다면 bfs를 통해서 맵에서 바이러스가 퍼지는 것을 구현하고 바이러스가 다 퍼졌을 때 안전영역의 크기를 출력해서 비교하여 안전 영역의 최대 크기를 구할 수 있도록 한다.</p>

<h2 id="결과">결과</h2>
<p><a href="https://github.com/ihmmaru99/BOJ/blob/main/14502/14502.cpp">14502 - 연구소</a></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span>
<span class="cp"># define MAX 8
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">map</span><span class="p">[</span><span class="n">MAX</span><span class="p">][</span><span class="n">MAX</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">temp</span><span class="p">[</span><span class="n">MAX</span><span class="p">][</span><span class="n">MAX</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dx</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">dy</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">Copy</span><span class="p">(</span><span class="kt">int</span> <span class="n">map</span><span class="p">[</span><span class="n">MAX</span><span class="p">][</span><span class="n">MAX</span><span class="p">],</span> <span class="kt">int</span> <span class="n">temp</span><span class="p">[</span><span class="n">MAX</span><span class="p">][</span><span class="n">MAX</span><span class="p">]){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bfs</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">check</span><span class="p">[</span><span class="n">MAX</span><span class="p">][</span><span class="n">MAX</span><span class="p">];</span>
    <span class="n">Copy</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">check</span><span class="p">);</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">){</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                    <span class="n">check</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">wall</span><span class="p">(</span><span class="kt">int</span> <span class="n">cnt</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">3</span><span class="p">){</span>
        <span class="n">bfs</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">wall</span><span class="p">(</span><span class="n">cnt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
                <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="n">Copy</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
                <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">wall</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
                <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="채점-결과">채점 결과</h2>
<p><img width="729" alt="스크린샷 2023-06-07 16 42 40" src="https://github.com/ihmmaru99/BOJ/assets/109266664/30922646-00fc-45aa-9fbe-8711ef6562b2" /></p>]]></content><author><name>임정빈</name></author><category term="BOJ" /><category term="Algorithm" /><category term="BFS" /><category term="C++" /><summary type="html"><![CDATA[연구소 난이도 골드 4]]></summary></entry></feed>